import React, { useState, useEffect } from 'react';
import styles from './FullOpenTest.module.scss';
import Box from '../../UI/Box/Box';
import Button from '../../UI/Button/Button';
import { ReactComponent as GoToMain } from '../../assets/icons/logout.svg';
import { useNavigate, useParams } from 'react-router-dom';
import Input from '../../UI/Input/Input';
import Modal from '../../UI/Modal/Modal';

import { getOpenQuestionTestById } from '../../store/service/OpenQuestionTest';

import { ReactComponent as Check } from '../../assets/icons/check.svg';

const FullOpenTest = () => {
    const navigate = useNavigate();
    const { testId } = useParams();
    const [testData, setTestData] = useState<any>(null);
    const [userAnswers, setUserAnswers] = useState<string[]>([]);
    const [isAnswered, setIsAnswered] = useState<boolean[]>([]);
    const [isEditing, setIsEditing] = useState<boolean[]>([]);
    const [isValid, setIsValid] = useState<boolean[]>([]);
    const [timeLeft, setTimeLeft] = useState<number>(0);
    const [modalVisible, setModalVisible] = useState(false);
    const [timerId, setTimerId] = useState<NodeJS.Timeout | null>(null);
    const [timerRunning, setTimerRunning] = useState<boolean>(true);

    useEffect(() => {
        const token = sessionStorage.getItem('token');
        if (token && testId) {
            getOpenQuestionTestById(testId, token)
                .then(data => {
                    setTestData(data);
                    setUserAnswers(Array(data.test.length).fill(''));
                    setIsAnswered(Array(data.test.length).fill(false));
                    setIsEditing(Array(data.test.length).fill(false));
                    setIsValid(Array(data.test.length).fill(false));
                    setTimeLeft(data.time * 60);
                })
                .catch(error => console.error('Error fetching test:', error));
        } else {
            console.error('Token or testId is undefined');
        }
    }, [testId]);

    useEffect(() => {
        if (timerRunning) {
            const timer = setTimeout(() => {
                setTimeLeft(prevTimeLeft => {
                    if (prevTimeLeft === 0) {
                        setTimerRunning(false);
                    }
                    return prevTimeLeft - 1;
                });
            }, 1000);
      
            return () => clearTimeout(timer);
        }
    }, [timerRunning, timeLeft]);

    const redirectToMainPage = () => {
        navigate('/');
    };

    const handleInputChange = (index: number, value: string) => {
        setUserAnswers(prevState => {
            const updatedAnswers = [...prevState];
            updatedAnswers[index] = value;
            return updatedAnswers;
        });
        setIsValid(prevState => {
            const updatedValidity = [...prevState];
            updatedValidity[index] = value.trim() !== '';
            return updatedValidity;
        });
    };

    const handleAnswerSubmit = (index: number) => {
        if (userAnswers[index].trim() !== '') {
            setIsAnswered(prevState => {
                const updatedState = [...prevState];
                updatedState[index] = true;
                return updatedState;
            });
            setIsEditing(prevState => {
                const updatedState = [...prevState];
                updatedState[index] = false;
                return updatedState;
            });
        } else {
            alert('Ответ не может быть пустым');
        }
    };

    const handleEditClick = (index: number) => {
        setIsEditing(prevState => {
            const updatedState = [...prevState];
            updatedState[index] = true;
            return updatedState;
        });
        setIsAnswered(prevState => {
            const updatedState = [...prevState];
            updatedState[index] = false;
            return updatedState;
        });
    };

    const openModal = () => {
        setModalVisible(true);
    };

    const closeModal = () => {
        setModalVisible(false);
    };

    const handleFinishTest = async () => {
        try {
            const token = sessionStorage.getItem('token');
            const userData = sessionStorage.getItem('userData');
            if (!token) {
                throw new Error('Токен отсутствует');
            }
            if (!userData) {
                throw new Error('Данные пользователя отсутствуют');
            }
            const { userId, full_name } = JSON.parse(userData) || {};
            if (!userId) {
                throw new Error('ID пользователя отсутствует');
            }
            if (!full_name) {
                throw new Error('Имя пользователя отсутствует');
            }
            
            const userTestResults = testData.test.map((question: any, index: any) => ({
                questionId: question.id,
                questionText: question.questionText,
                userAnswer: userAnswers[index],
            }));
    
            const requestData = {
                userId,
                full_name,
                testId: testData.id,
                testName: testData.name,
                answers: userTestResults,
            };
    
            console.log('Данные для отправки:', requestData);
            
            const response = await fetch(`${process.env.REACT_APP_API_EDUCATION}/api/createUserOpenTestResult/${testId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`,
                },
                body: JSON.stringify(requestData),
            });
    
            if (!response.ok) {
                throw new Error('Ошибка при отправке данных на сервер');
            }
    
            console.log('Результаты тестирования успешно созданы');
        } catch (error) {
            console.error('Ошибка при создании результатов тестирования:', error);
        }
        openModal();
        clearTimeout(timerId!);
        setTimerRunning(false);
    }; 

    const formatTime = (time: number) => {
        const hours = Math.floor(time / 3600);
        const minutes = Math.floor((time % 3600) / 60);
        const seconds = time % 60;
        return `${hours < 10 ? '0' + hours : hours}:${minutes < 10 ? '0' + minutes : minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
    };

    return (
        <div className={styles.wrapper}>
            <div className={styles.BlockLeft}>
                {/* <div>
                    <Box>
                        <div className={styles.GoBackToTheMainPage}>
                            <Button type="submit" variant="normal" onClick={redirectToMainPage}>
                                <div className={styles.GoToMain}>
                                    <GoToMain title="" />
                                </div>
                                Основная страница
                            </Button>
                        </div>
                    </Box>
                </div> */}
            </div>
            <div className={styles.BlockCenter}>
                <div className={styles.FullCoursContent}>
                    <div>
                        <Box>
                            <div className={styles.Name}>
                                <h1>{testData ? testData.name : 'Loading...'}</h1>
                            </div>
                        </Box>
                    </div>
                    <div className={styles.content}>
                        <div className={styles.TestBody}>
                        {testData && testData.test.map((question: any, index: number) => (
                            <Box key={index}>
                                <div className={styles.questionText}>
                                    <h2>{question.questionText}</h2>
                                </div>
                                {isAnswered[index] ? (
                                    <div className={styles.correctAnswer}>
                                        {userAnswers[index] || 'ваш ответ'}
                                        <Button variant="normal" onClick={() => handleEditClick(index)}>
                                            Изменить ответ
                                        </Button>
                                    </div>
                                ) : (
                                    <div className={styles.AnsvertInput}>
                                        <textarea 
                                            className={styles.CustomTextareaClass}
                                            placeholder="Ваш ответ" 
                                            value={userAnswers[index]}
                                            onChange={(e) => handleInputChange(index, e.target.value)} 
                                        />
                                        <Button type="submit" variant="success" onClick={() => handleAnswerSubmit(index)}>
                                            Ответить
                                        </Button>
                                    </div>
                                )}
                            </Box>
                        ))}
                        </div>
                    </div>
                </div>
            </div>
            <div className={styles.BlockRight}>
                <div>
                    <Box>
                        <div className={styles.finishBlock}>
                            <Button variant='success' onClick={handleFinishTest}>Закончить тестирование<Check/></Button>
                        </div>
                    </Box>
                </div>
               <div>
                    <Box>
                        <div className={styles.blockTime}>
                            <div className={styles.timer}>{formatTime(timeLeft)}</div>
                        </div>
                    </Box>
               </div>
            </div>
            <Modal isOpen={modalVisible} onClose={closeModal}>
                <div className={styles.headerModal}>
                    <h2>Результаты тестирования</h2>
                </div>
                <div className={styles.bodyModal}>
                    Результаты вашего тестирования оправлены на проверку, в ближайшее время результат будет отображен в вашей статистике.
                </div>
                <div className={styles.footerModal}>
                    <div className={styles.ButtonsBlock}>
                        <Button variant='success' onClick={redirectToMainPage}>Вернуться на главную</Button>
                    </div>
                </div>
            </Modal>
        </div>
    );
};

export default FullOpenTest;
